#include <iostream> // and system("pause")
#include <cmath> //математика
#include <cassert> //для дропа, если что
#include <utility> //для exchange
#include <vector>
//#include <windows.h>
#include <locale>
using namespace std;


//мы длжны постоянно помнить, что надо сохранять инвариантность, следовательно не надо создавать плохие объекты   ok
//еще надо допилить универсальные конструкторы   ok
//и сделать проверки в собственных конструкторах   ok

//а еще надо бы сделать 9) Создать еще что-будь 
//и в начале выбор на 1) создать  2) посмотреть на чадо

//надо отвязатся от консольки (сначла вводим точки, а потом пихаем их в вектор и в кажом классе можно этот вектор принимать)     
//и еще надо перенести периметр и площадь в классы соответвующие и сдлать их виртуальными (для того, чтбы для потомков тоде работало)   ok
//и просто еще допилить, чтобы все ок было
//а, еще надо подкорректировать == и сделать ретурн в проверке вместо исключений
//и еще надо в исключениях сделать класс ексепшн, чтобы было по кайфу        ok

class CStorage
{
public:
    vector <CPoint> VPoints;
    vector <CFigure> VFigures;
    vector <CPolyLine> VPolylines;
    vector <Ccycle_polyline> VCycle_polylines;
    vector <Cpolygon> VPolygones;
    vector <Ctriangle> VTriangles;
    vector <Cparallelogram> Vparallelogrames;
    vector <Ctrapezoid> VTrapezoids;
    vector <Cclear_polygon> VClear_polygones;
    vector <CRhombus> VRhombuses;

    ~CStorage()
    {
        VPoints.clear();  VTriangles.clear();
        VFigures.clear();  Vparallelogrames.clear();
        VPolylines.clear();  VTrapezoids.clear();
        VCycle_polylines.clear();  VClear_polygones.clear();
        VPolygones.clear();  VRhombuses.clear();

    }
};

class CFigure {
private:
    vector <CPoint> points_;
    vector <CPoint> sides_;
public:
    CPoint Get_point(int i) { return points_[i]; }
    CPoint Get_side(int i) { return sides_[i]; }
    vector <CPoint> Get_All_points() { return points_; }
    vector <CPoint> Get_All_sides() { return sides_; }
    int Get_size() { return sides_.size(); }
    void Set_point(static const CPoint point) { points_.push_back(point); }
    void Set_side(static const CPoint side) { sides_.push_back(side); }

    CFigure() {}
    CFigure(vector <CPoint> PlentyOfPoints)
    {
        SetFigure(PlentyOfPoints); 
        cout << "P = " << Find_P() << " and  S = " << Find_S() << endl;
    }

    void SetFigure(vector <CPoint> PlentyOfPoints)
    {
        points_.resize(PlentyOfPoints.size());
        for (int i = 0; i < PlentyOfPoints.size(); i++)
        {
            points_.at(i) = PlentyOfPoints.at(i);
        }
    }
    virtual bool Check_for_cycle() { return ((Get_point(0).Get_X() == Get_point(Get_size() - 1).Get_X()) && (Get_point(0).Get_Y() == Get_point(Get_size() - 1).Get_Y())); }
    //true - yes   false - no
    virtual bool Check_for_convexity()
    {
        try
        {
            if (!(Check_for_cycle()))
            {
                throw exception("Sorry, but this polyline not cycle!");
            }
            int X1, X2, Y1, Y2, X, Y;

            int help_turn = 0;
            int count = 0 - sides_.size();
            for (int i = 0; i < sides_.size() - 1; i++)
            {
                X1 = points_.at(i).Get_X();      Y1 = points_.at(i).Get_Y();      //мы берем координаты у точек
                X2 = points_.at(i + 1).Get_X();  Y2 = points_.at(i + 1).Get_Y();
                X = X2 - X1; Y = Y2 - Y1; //считаем координаты у ребра
                sides_.at(i).Set_XY(X, Y); //кладем координаты ребер как координаты точек в вспомогательный массив
            }
            X1 = points_.at(sides_.size() - 1).Get_X();      Y1 = points_.at(sides_.size() - 1).Get_Y(); //тут мы делаем то же самое, просто последний раз, вручную, ибо иначе мы бы вышли за пределы
            X2 = points_.at(0).Get_X();                      Y2 = points_.at(0).Get_Y();
            X = X2 - X1; Y = Y2 - Y1;
            sides_.at(sides_.size()).Set_XY(X, Y); //ребра запонены

            for (int i = 0; i < Get_size() - 1; i++) //проверяем выпуклость с помощью поворотов
            {
                X1 = sides_.at(i).Get_X();      Y1 = sides_.at(i).Get_Y();      //мы берем точки уже у ребер
                X2 = sides_.at(i + 1).Get_X();  Y2 = sides_.at(i + 1).Get_Y();
                help_turn = (X1 * Y2 - Y1 * X2); //формула поворота, >0, когда поворот налево; <0 - направо; =0 - коллинеарны
                if (help_turn < 0)
                {
                    count++; //будем по умолчанию обходить слева, таким образом если все ок, то в конце quantity = 0, а иначе все плохо
                }
            }

            return (count < 0);

        }
        catch (exception& ex)
        {
            cout << ex.what() << endl;
            return true;
        }

    }
    //false - ok     true - не выпуклый или не замкнутый 
    virtual bool Check_for_ideal()
    {
        for (int i = 0; i < sides_.size() - 1; i++)
        {
            if (!(sides_.at(i) == sides_.at(i + 1))) { return false; }
        }
        return true;
    }
    //true - yes     false - no

    virtual double Find_S()
    {
        int X1, X2, Y1, Y2;
        double S;
        double s1 = 0, s2 = 0;
        for (int i = 0; i < points_.size() - 1; i++)
        {
            X1 = points_.at(i).Get_X();      Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X();  Y2 = points_.at(i + 1).Get_Y();
            s1 += X1 * Y2;
            s2 += Y1 * X2;
        }
        S = ((s1 - s2) / 2);
        return S;
    }
    virtual double Find_P()
    {
        int X1, X2, Y1, Y2;
        double P;
        for (int i = 0; i < points_.size() - 1; i++)
        {
            X1 = points_.at(i).Get_X();     Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X(); Y2 = points_.at(i + 1).Get_Y();
            P += sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
        }
        return P;
    }
    virtual double Find_R() {}
    virtual double Find_r() {} //////////////////////////**************************************************************************
};
class CPoint // точка
{
private:
    int X_ = 0;
    int Y_ = 0;
public:
    CPoint(int x, int y) { Set_XY(x, y); }// обычный конструктор
    CPoint(int x) : X_(x), Y_(0) {}
    CPoint() : X_(0), Y_(0) {}
    CPoint(vector <CPoint> vpoints) :
        X_(vpoints.front().X_), Y_(vpoints.front().Y_) { Find_P(); Find_S(); }
    CPoint(const CPoint& another) : // конструктор копирования
        X_(another.X_), Y_(another.Y_)
    {}
    CPoint(CPoint&& another) noexcept : // конструктор перемещения
        X_(exchange(another.X_, 0)), Y_(exchange(another.Y_, 0))
    {}

    void SetPoint() // Set
    {
        int x, y;
        cout << "Point ("; cin >> x;
        cout << ";"; cin >> y;
        cout << ")" << endl;
        Set_XY(x, y);
    }

    int Get_X() { return X_; }
    int Get_Y() { return Y_; }
    void Set_XY(int x, int y)
    {
        X_ = x;
        Y_ = y;
    }


    void GetPoint() // Get
    {
        cout << "Point (" << X_ << ";" << Y_ << ")" << endl;
    }

    CPoint& operator= (const CPoint& another) // оператор =
    {
        if (&another == this)
            return *this;

        X_ = another.X_;
        Y_ = another.Y_;

        return *this;
    }

    friend bool operator== (const CPoint& another, const CPoint& that)
    { return ((another.X_ == that.X_) && (another.Y_ == that.Y_)); }
    friend istream& operator>> (istream& indata, CPoint point)
    {
        int x, y;
        cout << "("; indata >> x;
        cout << ";"; indata >> y;
        cout << ")" << endl;
        point.Set_XY(x, y);
        return indata;
    }
    
    void Find_P()
    {
        cout << "P.. Уау! Вы получили ничего! Вы прогрессируете дальше!" << endl;
    }
    void Find_S()
    {
        cout << "S.. Невозможно! Вы получили ничего! Ваш прогресс не знает пределов!" << endl;
    }
    ~CPoint()
    {}
};

class CPolyLine : public CFigure // ломаная
{
private:
public:
    CPolyLine() {}
    CPolyLine(vector <CPoint> PlentyOfPoints) { SetPolyLine(PlentyOfPoints); }

    void SetPolyLine(vector <CPoint> PlentyOfPoints)
    {
        SetFigure(PlentyOfPoints);
        cout << "P = " << Find_P() << " and  S = " << Find_S(0) << endl;
    }

    void GetPolyLine()
    {
        for (int i = 0; i < Get_size(); i++)
            Get_point(i).GetPoint();
    }

    const char* Find_S(int){ return "Невероятно! Путем своих усилий вы достигли ничего! Ваш прогресс вам аплодирует!"; }

    ~CPolyLine() { Get_All_points().clear(); }
};
class Ccycle_polyline : public CFigure // замкнутая ломаная
{
private:
public:


    Ccycle_polyline() {}
    Ccycle_polyline(vector <CPoint> PlentyOfPoints)
    {
        try
        {
            if (!(Check_for_cycle))
            {
                throw exception("Sorry, but this polyline not cycle");
            }
            SetCyclePolyline(PlentyOfPoints);
            cout << "P = " << Find_P() << " and  S = " << Find_S() << endl;
        }
        catch (exception& ex)
        {
            cout << ex.what() << endl;
        }
    }

    void SetCyclePolyline(vector <CPoint> PlentyOfPoints)
    {
        SetFigure(PlentyOfPoints);
    }

    void GetPolyLine()
    {
        for (int i = 0; i < Get_size(); i++)
            Get_point(i).GetPoint();
    }

    ~Ccycle_polyline()
    {
        Get_All_points().clear();
        Get_All_sides().clear();
    }
};
class Cpolygon : public CFigure // многоугольник выпуклый
{
private:
public:
    Cpolygon() {}
    Cpolygon(vector <CPoint> PlentyOfPoints)
    {
        try
        {
            if (Check_for_convexity())
            {
                throw exception("Sorry, but it's not a convexity polygon");
            }
            SetPolygon(PlentyOfPoints);
            cout << "P = " << Find_P() << " and  S = " << Find_S() << endl;
        }
        catch (exception& ex)
        {
            cout << ex.what() << endl;
        }
    }
    void SetPolygon(vector <CPoint> PlentyOfPoints) { SetFigure(PlentyOfPoints); }
    void GetPolygon()
    {
        for (int i = 0; i < Get_size(); i++)
            Get_point(i).GetPoint();
    }

    ~Cpolygon()
    {
        Get_All_points().clear();
        Get_All_sides().clear();
    }
};
class Ctriangle : public Cpolygon// треугольник
{
private:
public:
    Ctriangle() {}
    Ctriangle(vector <CPoint> PlentyOfPoints)
    {
        try
        {
            if (Check_for_convexity())
            {
                throw exception("Sorry, but it's not a convexity polygon");
            }
            SetPolygon(PlentyOfPoints);
            cout << "P = " << Find_P() << " and  S = " << Find_S() << endl;
            if (Check_for_real_triangle())
            {
                cout << "За вами кто-то следит....." << endl;
            }
            else
            {
                cout << "Нашим рабам не удалось получить идеально треугольную пирамиду - нужно больше золота. Народ любит вас, сир!" << endl;
            }
            
        }
        catch (exception& ex)
        {
            cout << ex.what() << endl;
        }
    }
    void SetTriangle(vector <CPoint> PlentyOfPoints) { SetFigure(PlentyOfPoints); }

    void GetTriangle()
    {
        for (int i = 0; i < 3; i++)
        {
            Get_point(i).GetPoint();
        }
    }



    bool Check_for_real_triangle() //каждая из сторон треугольника должна быть меньше, чем сумма двух других
    {

        return((sqrt(((Get_side(0).Get_X() - Get_side(2).Get_X()) * (Get_side(0).Get_X() - Get_side(2).Get_X())) + ((Get_side(0).Get_Y() - Get_side(2).Get_Y()) * (Get_side(0).Get_Y() - Get_side(2).Get_Y())))
            < (sqrt(((Get_side(1).Get_X() - Get_side(0).Get_X()) * (Get_side(1).Get_X() - Get_side(0).Get_X())) + ((Get_side(1).Get_Y() - Get_side(0).Get_Y()) * (Get_side(1).Get_Y() - Get_side(0).Get_Y())))
                + sqrt(((Get_side(2).Get_X() - Get_side(1).Get_X()) * (Get_side(2).Get_X() - Get_side(1).Get_X())) + ((Get_side(2).Get_Y() - Get_side(1).Get_Y()) * (Get_side(2).Get_Y() - Get_side(1).Get_Y())))))


            || (sqrt(((Get_side(1).Get_X() - Get_side(0).Get_X()) * (Get_side(1).Get_X() - Get_side(0).Get_X())) + ((Get_side(1).Get_Y() - Get_side(0).Get_Y()) * (Get_side(1).Get_Y() - Get_side(0).Get_Y())))
                < (sqrt(((Get_side(2).Get_X() - Get_side(1).Get_X()) * (Get_side(2).Get_X() - Get_side(1).Get_X())) + ((Get_side(2).Get_Y() - Get_side(1).Get_Y()) * (Get_side(2).Get_Y() - Get_side(1).Get_Y())))
                    + sqrt(((Get_side(0).Get_X() - Get_side(2).Get_X()) * (Get_side(0).Get_X() - Get_side(2).Get_X())) + ((Get_side(0).Get_Y() - Get_side(2).Get_Y()) * (Get_side(0).Get_Y() - Get_side(2).Get_Y())))))


            || (sqrt(((Get_side(2).Get_X() - Get_side(1).Get_X()) * (Get_side(2).Get_X() - Get_side(1).Get_X())) + ((Get_side(2).Get_Y() - Get_side(1).Get_Y()) * (Get_side(2).Get_Y() - Get_side(1).Get_Y())))
                < (sqrt(((Get_side(1).Get_X() - Get_side(0).Get_X()) * (Get_side(1).Get_X() - Get_side(0).Get_X())) + ((Get_side(1).Get_Y() - Get_side(0).Get_Y()) * (Get_side(1).Get_Y() - Get_side(0).Get_Y())))
                    + sqrt(((Get_side(0).Get_X() - Get_side(2).Get_X()) * (Get_side(0).Get_X() - Get_side(2).Get_X())) + ((Get_side(0).Get_Y() - Get_side(2).Get_Y()) * (Get_side(0).Get_Y() - Get_side(2).Get_Y()))))));

    }
    ~Ctriangle()
    {
        Get_All_points().clear();
        Get_All_sides().clear();
    }
};
class Ctrapezoid : public CFigure // трапеция
{
private:
    double P_;
    double S_;
    vector<CPoint> points_;
    vector<double> sides_;
public:

    int X1 = 0, X2 = 0, Y1 = 0, Y2 = 0;

    Ctrapezoid()
    {
        points_.reserve(4);
        sides_.reserve(4);
        for (int i = 0; i < 4; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void SetTrapezoid()
    {
        points_.resize(4);
        sides_.reserve(4);
        for (int i = 0; i < 4; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void GetTrapezoid()
    {
        for (int i = 0; i < 3; i++)
        {
            points_.at(i).GetPoint();
        }
    }
    double Get_S() { return S_; }
    double Get_P() { return P_; }

    void Find_P()
    {
        for (int i = 0; i < 3; i++)
        {
            X1 = points_.at(i).Get_X();     Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X(); Y2 = points_.at(i + 1).Get_Y(); /// нужна проверка на выпуклость и проверка на параллельность (можно еще и на 90)
            P_ += sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
            sides_.at(i) = sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
        }
        cout << "P = " << P_ << endl;
    }
    void Find_S()
    {
        double s1 = 0, s2 = 0;
        for (int i = 0; i < 3; i++)
        {
            X1 = points_.at(i).Get_X();      Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X();  Y2 = points_.at(i + 1).Get_Y();
            s1 += X1 * Y2;
            s2 += Y1 * X2;
        }
        S_ = ((s1 - s2) / 2);
        cout << "S = " << S_ << endl;
    }
    ~Ctrapezoid()
    {
        points_.clear();
        sides_.clear();
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Cclear_polygon : public Cpolygon // правильный многоугольник
{
private:
public:
    Cclear_polygon() {}
    Cclear_polygon(vector <CPoint> PlentyOfPoints)
    {
        try
        {
            if (Check_for_convexity())
            {
                throw exception("Sorry, but it's not a convexity polygon");
            }
            if (!(Check_for_ideal()))
            {
                throw exception("Вся симметричность и справедливость всего мироздания, в котором мы так преисполнились, впрочем как и адекватность, безвозвратно утеряна....");
            }
            SetClearPolygon(PlentyOfPoints);
            /*угол, который вам нужен, это angle = 2 * pi / numPoints.

затем, начиная вертикально над началом координат с размером многоугольника, заданного radius:

for (int i = 0; i < numPoints; i++)
{
    x = centreX + radius * sin(i * angle);
    y = centreY + radius * cos(i * angle);
}
если ваш центр является источником, просто игнорируйте centreX и centreY термины, как они будут 0,0.*/
            cout << "P = " << Find_P() << " and  S = " << Find_S() << endl;
        }
        catch (exception& ex)
        {
            cout << ex.what() << endl;
        }

    }

    void SetClearPolygon(vector <CPoint> PlentyOfPoints) { SetFigure(PlentyOfPoints); }
    void GetClearPolygon()
    {
        for (int i = 0; i < Get_size(); i++)
            Get_point(i).GetPoint();
    }

};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Cparallelogram : public Cpolygon
{

};
//////////////////////////////////////////////////////////////////////////////////////////////////////
class CRhombus : public Cparallelogram
{

};
//////////////////////////////////////////////////////////////////////////////////////////////////////




vector <CPoint> AskForCreate(vector <CPoint> PlentyOfPoints)
{

    cout << endl << "Пожалуйста, вводите точки, из которых хотите воплощать свои геометрические мечты в реальность:";
    CPoint start_point;

    for (CPoint start_point; ((cin.peek() != '`') || (cin.peek() != 'ё')) && cin >> start_point;)
    {
        PlentyOfPoints.push_back(start_point);
    }

    if (PlentyOfPoints.size() < 0)
    {
        cout << "Ну, тут наши полномочия всё, окончены..." << endl;
        return;
    }
    else if (PlentyOfPoints.size() == 0)
    {   
        cout << "Поздравляем! Вы сделали абсолютно ничего, это успех! Вы прогрессируете!" << endl;
        return;
    }

    cout << "из этих точек вы можете сотворить: " << endl << "0) Ничего не хочу." << endl;;
    if (PlentyOfPoints.size() == 1) cout << "1) Точку. Просто одинокую точку...   хнык(   " << endl;
    else if (PlentyOfPoints.size() > 1)  cout << "1) Ломаную.";                                                                                              //если захотим 2(или более) отдельных точки, то дульки с маком
    else if (PlentyOfPoints.size() > 3)  cout << "2) Замкнутую ломаную." << endl << "3) Многоугольник." << endl << "4) Правильный многоугольник." << endl;
    switch (PlentyOfPoints.size())
    {
    case 3:
    {
        cout << "2)               Илюминатиии" << endl << "3)  Идельного илюминатии" << endl;
    }
    case 4:
        cout << "5) Трапецию." << endl << "6) Параллелограмм (может скоро)." << endl << "7) Ромб (может скоро)." << endl;
    }
    cout << endl << "Итак, что же вы хотите?" << endl;
    return PlentyOfPoints;
}
//просто ввод quantity и предложение вариантов || return -1, если quantity < 0, return 0, если quantity = 0

void Create(vector <CPoint> PlentyOfPoints, CStorage& Storage)
{
    int comand;

    cin >> comand;
    switch (comand)
    {
    case 0:
    {
        cout << "Хорошо, да будет так." << endl << "Удачи и хорошего настроения)" << endl;
        throw 0;
    }
    case 1:
        if (PlentyOfPoints.size() == 1) //точечка
        {
            cout << "CPoint" << endl;
            CPoint point(PlentyOfPoints);
            Storage.VPoints.push_back(point);
            point.GetPoint();
            cout << endl;
        }
        else if (PlentyOfPoints.size() >= 2) //ломаная
        {
            cout << "CPolyLine" << endl;
            CPolyLine lieine(PlentyOfPoints);
            Storage.VPolylines.push_back(lieine);
            lieine.GetPolyLine();
            lieine.Find_P(lieine);
            lieine.Find_S(lieine);
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 10;
        }
    case 2:

        if (PlentyOfPoints.size() > 3) //замкнутая ломаная
        {
            cout << "Ccycle_polyline" << endl;
            Ccycle_polyline lieil(PlentyOfPoints);
            Storage.VCycle_polylines.push_back(lieil);
            /*get
            check for cycle*/
            cout << endl;
        }
        else if (PlentyOfPoints.size() == 3) //треугольник
        {
            cout << "Ctriangle" << endl;
            Ctriangle ABC(PlentyOfPoints);
            Storage.VTriangles.push_back(ABC);
            /*ABC.Find_S();
            * check for 90 ()
            * check for convexity
            * check for cycle
            * check for clear ()
            * Get
            * (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 20;
        }
    case 3:
        if (PlentyOfPoints.size() > 3) //многоугольник
        {
            cout << "Cpolygon" << endl;
            Cpolygon ABCDEF(PlentyOfPoints);
            Storage.VPolygones.push_back(ABCDEF);
            /*
            get
            check for conv
            check for cycle
            */
            cout << endl;
        }
        else if (PlentyOfPoints.size() == 3) //правильный треугольник
        {
            cout << "Cclear_polygon" << endl;
            Cclear_polygon clear_ABCDEF(PlentyOfPoints);
            Storage.VClear_polygones.push_back(clear_ABCDEF);
            /*ABC.Find_S();
            * check for 90 ()
            * check for convexity
            * check for cycle
            * check for clear ()
            * Get
            * (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 30;
        }
    case 4:
    {
        if (PlentyOfPoints.size() > 3)
        {
            cout << "Cclear_polygon" << endl;
            Cclear_polygon clear_ABCDEF(PlentyOfPoints);
            Storage.VClear_polygones.push_back(clear_ABCDEF);
            /*
                get
                check for conv
                check for cycle
                check for ideal
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 40;
        }
    }
    case 5:
        if (PlentyOfPoints.size() == 4)
        {
            cout << "Ctrapezoid" << endl;
            Ctrapezoid VQOW(PlentyOfPoints);
            Storage.VTrapezoids.push_back(VQOW);
            /*
                get
                check for conv
                check for cycle
                check for ||
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 50;
        }
    case 6:
        if (PlentyOfPoints.size() == 4)
        {
            cout << "Cparallelogram" << endl;
            Cparallelogram ABCD(PlentyOfPoints);
            Storage.Vparallelogrames.push_back(ABCD);
            /*
                get
                check for conv
                check for cycle
                check for || and ||
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 60;
        }
    case 7:
        if (PlentyOfPoints.size() == 4)
        {
            cout << "CRhombus" << endl;
            CRhombus ROMB(PlentyOfPoints);
            Storage.VRhombuses.push_back(ROMB);
            /*
                get
                check for conv
                check for cycle
                check for || and ||
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 70;
        }

    default:
    {
        cout << "Хочу обратиться к этому Обэмэ: тут беды с башкой, все-го хо-ро - ше-го! " << endl;
        throw - 2;
    }
    }
}
//throw 0, если не хотим, -2, если незнакомая команда, -*0, если в каком-то кейсе что-то пошло не так

void AskForAgain(vector <CPoint> PlentyOfPoints)
{
    cout << "Хотите сделать что-нибудь еще разок? (Y/N) ";
    char command;
    cin >> command;
    if ((command == 'Y') || (command == 'y'))
    {
        vector <CPoint> PlentyOfPoints = AskForCreate(PlentyOfPoints); //спрашиваем quantity и предлагаем создание
        if ((PlentyOfPoints.size() == 0) || (PlentyOfPoints.size() == -1)) //если quantity немного не такое
        {
            try
            {
                AskForAgain(PlentyOfPoints); //предлагаем заново
            }
            catch (int& ex) //ну а если не хотят, то звершение работы сознания
            {
                if (ex == 0)
                    throw 0; // не хотят - выходим
                else
                    throw - 1; // другой символ ввели
            }
        }
    }
    else if ((command == 'N') || (command == 'n'))
    {
        cout << "Удачи)"; throw 0;
    }
    else
        throw - 1;
}
//throw -1, когда что-т поломается, и 0, если не хотим

int main()
{
    setlocale(LC_ALL, "Rus");
    CStorage Storage;
    vector <CPoint> PlentyOfPoints;

    cout << "Привет!" << endl;
    cout << "Пока что все работает, вас приветсвует мини-терминал по созданию всяких геометрических штук!)" << endl;
    PlentyOfPoints = AskForCreate(PlentyOfPoints); //вводим все точки и предлагаем создание
    if ((PlentyOfPoints.size() == 0) || (PlentyOfPoints.size() == -1)) //если quantity немного не такое
    {
        try
        {
            AskForAgain(PlentyOfPoints); //предлагаем заново
        }
        catch (int& ex) //ну а если не хотят, то звершение работы сознания
        {
            if (ex == 0)
                return 0; // не хотят
            else
            {
                cout << "Error №" << ex << endl;
                return -1; // другой символ ввели
            }
        }
    }

    try
    {
        Create(PlentyOfPoints, Storage); //пытаемся создать
    }
    catch (int& ex) //что-то идет не так
    {
        if (ex == 0) // не хотят создавать - не надо
        {
            return 0;
        }

        try //в других случаях мы предлагаем заново
        {
            AskForAgain(PlentyOfPoints);
        }
        catch (int& ex) //ну а если не хотят, то звершение работы сознания
        {
            if (ex == 0)
                return 0;//не хотят
            else
                return -1; // ввели другой символ
        }
    }




    system("pause");
    return 0;
}
