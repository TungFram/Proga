#include <iostream> // and system("pause")
#include <cmath> //математика
#include <cassert> //для дропа, если что
#include <utility> //для exchange
#include <vector>
//#include <windows.h>
#include <locale>
using namespace std;


//мы длжны постоянно помнить, что надо сохранять инвариантность, следовательно не надо создавать плохие объекты
//еще надо допилить универсальные конструкторы
//и сделать проверки в собственных конструкторах

class CStorage
{
public:
    vector <CPoint> VPoints;
    vector <CFigure> VFigures;
    vector <CPolyLine> VPolylines;
    vector <Ccycle_polyline> VCycle_polylines;
    vector <Cpolygon> VPolygones;
    vector <Ctriangle> VTriangles;
    vector <Cparallelogram> Vparallelogrames;
    vector <Ctrapezoid> VTrapezoids;
    vector <Cclear_polygon> VClear_polygones;
    vector <CRhombus> VRhombuses;
};

class CFigure {
private:
    vector <CPoint> points_;
    vector <CPoint> sides_;
public: 
    CPoint Get_point(int i) { return points_[i]; }
    CPoint Get_side(int i) { return sides_[i]; }
    int Get_size() { return sides_.size(); }
    CFigure(int i)
    {
        int quatity, x, y;
        cout << "Quantity of point: ";//////////////////////////////////////////////////////////////////////////////////////////////////////
        cin >> quatity;
        
    }
    bool Check_for_cycle()
    {

        if (Get_point(0) == Get_point(Get_size() - 1))
        {
            cout << "Yea! This polyline is cycle! Allright!" << endl;//////////////////////////////////////////////////////////////
            return true;
        }
        else
        {
            cout << "Sorry, but this polyline not cycle" << endl;
            return false;
        }

    }
    bool Check_for_convexity() = 0;//////////////////////////////////////////////////////////////////////////////////////////////////////

};
class CPoint // точка
{
private:
    int X_ = 0;
    int Y_ = 0;
public:
    int X, Y;
    CPoint(int x, int y) { Set_XY(x, y); }// обычный конструктор
    CPoint(int x) : X_(x), Y_(0) {}
    CPoint() : X_(0), Y_(0) {}

    CPoint(const CPoint& another) : // конструктор копирования
        X_(another.X_), Y_(another.Y_)
    {}
    CPoint(CPoint&& another) noexcept : // конструктор перемещения
        X_(exchange(another.X_, 0)), Y_(exchange(another.Y_, 0))
    {}

    void SetPoint() // Set
    {
        int x, y;
        cout << "Point ("; cin >> x;
        cout << ";"; cin >> y;
        cout << ")" << endl;
        Set_XY(x, y);
    }

    int Get_X() { return X_; }
    int Get_Y() { return Y_; }
    void Set_XY(int x, int y)
    {
        X_ = x;
        Y_ = y;
    }


    void GetPoint() // Get
    {
        cout << "Point (" << X_ << ";" << Y_ << ")" << endl;
    }

    CPoint& operator= (const CPoint& another) // оператор =
    {
        if (&another == this)
            return *this;

        X_ = another.X_;
        Y_ = another.Y_;

        return *this;
    }

    friend bool operator== (const CPoint& another , const CPoint& that)//////////////////////////////////////////////////////////////////////////////////////////////////////
    {
        if ((&another.X_ == this) &&
            (&another.Y_ == this))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /*
    istream& operator>> (istream& indata)
    {
        int x, y;
        cout << "("; indata >> X_;
        cout << ";"; indata >> Y_;
        cout << ")" << endl;
        return indata;
    }
    */
    ~CPoint()
    {}
};

class CPolyLine : public CFigure // ломаная
{
private:
    double P_ = 0;
    vector<CPoint> points_;
public:
    int X1 = 0, X2 = 0, Y1 = 0, Y2 = 0;

    CPolyLine(int quantity)
    {
        SetPolyLine(quantity);
    }

    void SetPolyLine(int quantity)
    {
        points_.resize(quantity);
        for (int i = 0; i < quantity; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void GetPolyLine()
    {
        for (int i = 0; i < points_.size(); i++)
            points_.at(i).GetPoint();
    }
    int GetQuantity() { return points_.size(); }
    vector<CPoint> GetVector() { return points_; }


    void Find_P()
    {
        for (int i = 0; i < points_.size() - 1; i++)
        {
            X1 = points_.at(i).Get_X();     Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X(); Y2 = points_.at(i + 1).Get_Y();
            P_ += sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
        }
        cout << "P = " << P_ << endl;
    }
    ~CPolyLine()
    {
        points_.clear();
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Ccycle_polyline : public CPolyLine // замкнутая ломаная
{
private:
    bool status_;
    double S_;
public:
    vector<CPoint> help = GetVector();
    int quantity = GetQuantity();

    Ccycle_polyline()
    {
    }

    ~Ccycle_polyline()
    {
        help.clear();
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Cpolygon : public Ccycle_polyline // многоугольник выпуклый
{
private:
    bool convexity_ = false;
public:
    vector<CPoint> help_side = help;

    Cpolygon()
    {
        Check_for_convexity();
    }

    void Check_for_convexity()
    {


        float help_turn = 0;
        int count = 0 - quantity;
        for (int i = 0; i < quantity - 1; i++)
        {
            X1 = help.at(i).Get_X();      Y1 = help.at(i).Get_Y();      //мы берем точки у точек
            X2 = help.at(i + 1).Get_X();  Y2 = help.at(i + 1).Get_Y();
            X = X2 - X1; Y = Y2 - Y1; //считаем координаты у ребра
            help_side.at(i).Set_XY(X, Y); //кладем координаты ребер как координаты точек в вспомогательный массив
        }
        X1 = help.at(quantity - 1).Get_X();      Y1 = help.at(quantity - 1).Get_Y(); //тут мы делаем то же самое, просто последний раз, вручную, ибо иначе мы бы вышли за пределы
        X2 = help.at(0).Get_X();  Y2 = help.at(0).Get_Y();
        X = X2 - X1; Y = Y2 - Y1;
        help_side.at(quantity).Set_XY(X, Y); //ребра запонены

        for (int i = 0; i < quantity - 1; i++) //проверяем выпуклость с помощью поворотов
        {
            X1 = help_side.at(i).Get_X();      Y1 = help_side.at(i).Get_Y();      //мы берем точки уже у ребер
            X2 = help_side.at(i + 1).Get_X();  Y2 = help_side.at(i + 1).Get_Y();
            help_turn = (X1 * Y2 - Y1 * X2); //формула поворота, >0, когда поворот налево; <0 - направо; =0 - коллинеарны
            if ((help_turn < 0) || (help_turn = 0))
            {
                count++; //будем по умолчанию обходить слева, таким образом если все ок, то в конце quantity = 0, а иначе все плохо
            }
        }
        if (count < 0)
        {
            convexity_ = false;
            cout << "Sorry, but it's not a convexity polygon" << endl;
        }
        else
        {
            convexity_ = true;
            cout << "All is clear, convexity is OK)" << endl;
        }
        assert(convexity_ = true);
    }
    ~Cpolygon()
    {
        help_side.clear();
        help.clear();
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Ctriangle : public Cpolygon// треугольник
{
private:
    double S_;
    double P_;
    vector<CPoint> points_;
    vector<double> sides_;
    bool Real_triangle;
    //bool Check_for_90;
public:
    int X1 = 0, X2 = 0, Y1 = 0, Y2 = 0;

    Ctriangle()
    {
        points_.reserve(3);
        sides_.reserve(3);
        for (int i = 0; i < 3; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void SetTriangle()
    {
        points_.resize(3);
        sides_.reserve(3);
        for (int i = 0; i < 3; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void GetTriangle()
    {
        for (int i = 0; i < 3; i++)
        {
            points_.at(i).GetPoint();
        }
    }
    double Get_S() { return S_; }
    double Get_P() { return P_; }

    void Find_P()
    {
        for (int i = 0; i < 2; i++)
        {
            X1 = points_.at(i).Get_X();     Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X(); Y2 = points_.at(i + 1).Get_Y();
            P_ += sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
            sides_.at(i) = sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
        }
        cout << "P = " << P_ << endl;
    }
    void Find_S()
    {
        double s1 = 0, s2 = 0;
        for (int i = 0; i < 2; i++)
        {
            X1 = points_.at(i).Get_X();      Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X();  Y2 = points_.at(i + 1).Get_Y();
            s1 += X1 * Y2;
            s2 += Y1 * X2;
        }
        S_ = ((s1 - s2) / 2);
        cout << "S = " << S_ << endl;
    }
    void Check_for_real_triangle() //каждая из сторон треугольника должна быть меньше, чем сумма двух других
    {

        if ((sides_.at(0) < (sides_.at(1) + sides_.at(2))) || (sides_.at(1) < (sides_.at(0) + sides_.at(2))) || (sides_.at(2) < (sides_.at(0) + sides_.at(1))))
        {
            Real_triangle = true;
            cout << "Yes, it's real triangle!" << endl;
        }
        else
        {
            Real_triangle = false;
            cout << "Oh, this is not Iluminat(" << endl;
            assert(Real_triangle = true);
        }

    }
    ~Ctriangle()
    {
        sides_.clear();
        points_.clear();
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Ctrapezoid : public CFigure // трапеция
{
private:
    double P_;
    double S_;
    vector<CPoint> points_;
    vector<double> sides_;
public:

    int X1 = 0, X2 = 0, Y1 = 0, Y2 = 0;

    Ctrapezoid()
    {
        points_.reserve(4);
        sides_.reserve(4);
        for (int i = 0; i < 4; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void SetTrapezoid()
    {
        points_.resize(4);
        sides_.reserve(4);
        for (int i = 0; i < 4; i++)
        {
            points_.at(i).SetPoint();
        }
    }

    void GetTrapezoid()
    {
        for (int i = 0; i < 3; i++)
        {
            points_.at(i).GetPoint();
        }
    }
    double Get_S() { return S_; }
    double Get_P() { return P_; }

    void Find_P()
    {
        for (int i = 0; i < 3; i++)
        {
            X1 = points_.at(i).Get_X();     Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X(); Y2 = points_.at(i + 1).Get_Y(); /// нужна проверка на выпуклость и проверка на параллельность (можно еще и на 90)
            P_ += sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
            sides_.at(i) = sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
        }
        cout << "P = " << P_ << endl;
    }
    void Find_S()
    {
        double s1 = 0, s2 = 0;
        for (int i = 0; i < 3; i++)
        {
            X1 = points_.at(i).Get_X();      Y1 = points_.at(i).Get_Y();
            X2 = points_.at(i + 1).Get_X();  Y2 = points_.at(i + 1).Get_Y();
            s1 += X1 * Y2;
            s2 += Y1 * X2;
        }
        S_ = ((s1 - s2) / 2);
        cout << "S = " << S_ << endl;
    }
    ~Ctrapezoid()
    {
        points_.clear();
        sides_.clear();
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Cclear_polygon : public Cpolygon // правильный многоугольник
{
private:
    bool ideal_ = true;
    double R_;
    double r_;
public:
    void Check_for_ideal()
    {
        for (int i = 0; i < quantity - 1; i++)
        {
            if (!(help_side.at(i) == help_side.at(i + 1)))
            {
                ideal_ = false;
                cout << "Sorry, but this polygon isn't clear..." << endl;
                assert(ideal_ = false);
            }
        }
    }

    void Find_r()
    {
        X = help_side.at(0).Get_X(); Y = help_side.at(0).Get_Y();
        r_ = ************************************************************************************
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Cparallelogram : public Cpolygon
{

};
//////////////////////////////////////////////////////////////////////////////////////////////////////
class CRhombus : public Cparallelogram
{

};
//////////////////////////////////////////////////////////////////////////////////////////////////////


double Find_P(CFigure figure);

int AskForCreate()
{
    int quantity;

    cout << endl << "Пожалуйста, введите количество точек, из которых хотите сотворить нечто (оно не оживет) : ";
    cin >> quantity;

    if (quantity < 0)
    {
        cout << "Ну, тут наши полномочия всё, окончены..." << endl;
        return -1;
    }
    else if (quantity == 0)
    {
        cout << "Поздравляем! Вы сделали абсолютно ничего, это успех! Вы прогрессируете!" << endl;
        return 0;
    }

    cout << "из " << quantity << "точек вы можете сотворить: " << endl << "0) Ничего не хочу." << endl;;
    if (quantity == 1) cout << "1) Точку. Просто одинокую точку...   хнык(   " << endl;
    else if (quantity > 1)  cout << "1) Ломаную.";                                                                                              //если захотим 2(или более) отдельных точки, то дульки с маком
    else if (quantity > 3)  cout << "2) Замкнутую ломаную." << endl << "3) Многоугольник." << endl << "4) Правильный многоугольник." << endl;
    switch (quantity)
    {
    case 3:
    {
        cout << "2)               Илюминатиии" << endl << "3)  Идельного илюминатии" << endl;
    }
    case 4:
        cout << "5) Трапецию." << endl << "6) Параллелограмм (может скоро)." << endl << "7) Ромб (может скоро)." << endl;
    }
    cout << endl << "Итак, что же вы хотите?" << endl;
    return quantity;
}
//просто ввод quantity и предложение вариантов || return -1, если quantity < 0, return 0, если quantity = 0

void Create(const int& quantity, CStorage& Storage)
{
    int comand;

    cin >> comand;
    switch (comand)
    {
    case 0:
    {
        cout << "Хорошо, да будет так." << endl << "Удачи и хорошего настроения)" << endl;
        throw 0;
    }
    case 1:
        if (quantity == 1) //точечка
        {
            cout << "CPoint" << endl;
            CPoint point;
            Storage.VPoints.push_back(point);
            point.GetPoint();
            cout << endl;
        }
        else if (quantity >= 2) //ломаная
        {
            cout << "CPolyLine" << endl;
            CPolyLine lieine(quantity);
            Storage.VPolylines.push_back(lieine);
            /*get*/
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw -10;
        }
    case 2:

        if (quantity > 3) //замкнутая ломаная
        {
            cout << "Ccycle_polyline" << endl;
            Ccycle_polyline lieil;
            Storage.VCycle_polylines.push_back(lieil);
            /*get
            check for cycle*/
            cout << endl;
        }
        else if (quantity == 3) //треугольник
        {
            cout << "Ctriangle" << endl;
            Ctriangle ABC;
            Storage.VTriangles.push_back(ABC);
            /*ABC.Find_S();
            * check for 90 ()
            * check for convexity
            * check for cycle
            * check for clear ()
            * Get
            * (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw -20;
        }
    case 3:
        if (quantity > 3) //многоугольник
        {
            cout << "Cpolygon" << endl;
            Cpolygon ABCDEF;
            Storage.VPolygones.push_back(ABCDEF);
            /*
            get
            check for conv
            check for cycle
            */
            cout << endl;
        }
        else if (quantity == 3) //правильный треугольник
        {
            cout << "Cclear_polygon" << endl;
            Cclear_polygon clear_ABCDEF;
            Storage.VClear_polygones.push_back(clear_ABCDEF);
            /*ABC.Find_S();
            * check for 90 ()
            * check for convexity
            * check for cycle
            * check for clear ()
            * Get
            * (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 30;
        }
    case 4:
    {
        if (quantity > 3)
        {
            cout << "Cclear_polygon" << endl;
            Cclear_polygon clear_ABCDEF;
            Storage.VClear_polygones.push_back(clear_ABCDEF);
            /*
                get
                check for conv
                check for cycle
                check for ideal
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 40;
        }
    }
    case 5:
        if (quantity == 4)
        {
            cout << "Ctrapezoid" << endl;
            Ctrapezoid VQOW;
            Storage.VTrapezoids.push_back(VQOW);
            /*
                get
                check for conv
                check for cycle
                check for ||
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 50;
        }
    case 6:
        if (quantity == 4)
        {
            cout << "Cparallelogram" << endl;
            Cparallelogram ABCD;
            Storage.Vparallelogrames.push_back(ABCD);
            /*
                get
                check for conv
                check for cycle
                check for || and ||
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 60;
        }
    case 7:
        if (quantity == 4)
        {
            cout << "CRhombus" << endl;
            CRhombus ROMB;
            Storage.VRhombuses.push_back(ROMB);
            /*
                get
                check for conv
                check for cycle
                check for || and ||
                (r R)
            */
            cout << endl;
        }
        else
        {
            cout << "Не известно как, но вы сломали устройство мира, в котором так преисполнились...";
            throw - 70;
        }

    default:
        {
            cout << "Хочу обратиться к этому Обэмэ: тут беды с башкой, все-го хо-ро - ше-го! " << endl;
            throw -2;
        }
    }
}
//throw 0, если не хотим, -2, если незнакомая команда, -*0, если в каком-то кейсе что-то пошло не так

void AskForAgain() 
{
    cout << "Хотите сделать что-нибудь еще разок? (Y/N) ";
    char command;
    cin >> command;
    if (command == 'Y')
    {
        int help = AskForCreate(); //спрашиваем quantity и предлагаем создание
        if ((help == 0) || (help == -1)) //если quantity немного не такое
        {
            try
            {
                AskForAgain(); //предлагаем заново
            }
            catch (int& ex) //ну а если не хотят, то звершение работы сознания
            {
                if (ex == 0)
                    throw 0; // не хотят - выходим
                else
                    throw -1; // другой символ ввели
            }
        }
    }
    else if (command == 'N')
    {
        cout << "Удачи)"; throw 0;
    }
    else
        throw - 1;
}    
//throw -1, когда что-т поломается, и 0, если не хотим

int main()
{
    setlocale(LC_ALL, "Rus");
    CStorage Storage;

    cout << "Привет!" << endl;
    cout << "Пока что все работает, вас приветсвует мини-терминал по созданию всяких геометрических штук!)" << endl;
    int help = AskForCreate(); //спрашиваем quantity и предлагаем создание
    if ((help == 0) || (help == -1)) //если quantity немного не такое
    {
        try
        {
            AskForAgain(); //предлагаем заново
        }
        catch(int& ex) //ну а если не хотят, то звершение работы сознания
        {
            if (ex == 0)
                return 0; // не хотят
            else
                return -1; // другой символ ввели
        }
    }
   
    try 
    { 
        Create(help, Storage); //пытаемся создать
    }
    catch (int& ex) //что-то идет не так
    {
        if (ex == 0) // не хотят создавать - не надо
        {
            return 0;
        }

        try //в других случаях мы предлагаем заново
        {
            AskForAgain();
        }
        catch(int& ex) //ну а если не хотят, то звершение работы сознания
        {
            if (ex == 0)
                return 0;//не хотят
            else
                return -1; // ввели другой символ
        }
    }
            



    system("pause");
    return 0;
}



double Find_P(CFigure figure)
{
    int X1, X2, Y1, Y2;
    double P;
    for (int i = 0; i < figure.Get_size() - 1; i++)
    {
        X1 = figure.Get_point(i).Get_X();     Y1 = figure.Get_point(i).Get_Y();
        X2 = figure.Get_point(i + 1).Get_X(); Y2 = figure.Get_point(i + 1).Get_Y();
        P += sqrt(((X2 - X1) ^ 2) + ((Y2 - Y1) ^ 2));
    }
    return P;
}

void Find_P(CPoint point)
{
    cout << "Уау! Вы получили ничего! Вы прогрессируете дальше!" << endl;
}

 double Find_S(CFigure figure) 
    {
        int X1, X2, Y1, Y2;
        double S;
        double s1 = 0, s2 = 0;
        for (int i = 0; i < figure.Get_size() - 1; i++)
        {
            X1 = figure.Get_point(i).Get_X();      Y1 = figure.Get_point(i).Get_Y();
            X2 = figure.Get_point(i + 1).Get_X();  Y2 = figure.Get_point(i + 1).Get_Y();
            s1 += X1 * Y2;
            s2 += Y1 * X2;
        }
        S = ((s1 - s2) / 2);
        return S;
    }

void Find_S(CPoint point)
{
    cout << "Невозможно! Вы получили ничего! Ваш прогресс не знает пределов!" << endl;
}
